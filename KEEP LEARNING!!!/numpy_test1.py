# 100 numpy objectives: https://pythonworld.ru/numpy/100-exercises.html
import numpy as np

arr1 = np.array([0, 1, 4, 6, 3])  # np.sum(a); a.max(); a.min();
arr2 = np.zeros((3, 5))  # создает массив размера 3х5 нулями
arr3 = np.ones((2, 3, 2))  # создает два массива размера 3х2 и заполняет его единицами
arr4 = np.eye(4)  # создает единичную матрицу
arr5 = np.empty((3, 3))  # создает массив без его заполнения(рандомные значения, мусор в памяти на данный момент)
arr6 = np.arange(10, 30, 5)  # последовательность
arr7 = np.linspace(0, 2, 9)  # 9 чисел от 0 до 2 включительно


def f1(i, j):
    return 3 * i + j


arr8 = np.fromfunction(f1, (3, 4))  # применяет функцию ко всем комбинациям индексов
arr9 = np.array([[0, 1, 2, 3],
                 [10, 11, 12, 13],
                 [20, 21, 22, 23],
                 [30, 31, 32, 33],
                 [40, 41, 42, 43]])
# arr9[2, 3]  # Вторая строка, третий столбец. (arr9[2][3])
# arr9[:, 2]  # Третий столбец)
# arr9[:2]  # Первые две строки
# arr9[1:3, : : ]  # Вторая и третья строки

arr10 = np.array(([[0, 1, 2], [10, 12, 13]], [[100, 101, 102], [110, 112, 113]]))
# for el in arr10.flat:  # если нужно перебрать поэлементно весь массив, как если бы он был одномерным
#     print(el, end=' ')

arr11 = np.array([[[0,   1,   2],
                   [10,  12,  13]],

                  [[100, 101, 102],
                   [110, 112, 113]]])
# print(arr11.shape)  # определяет число элементов вдоль каждой оси
# arr11.ravel()  # Делает массив плоским   array([  0,   1,   2,  10,  12,  13, 100, 101, 102, 110, 112, 113])
# arr11.shape = (6, 2)  # Изменение формы
# arr1.transpose()  # Транспонирование
# arr11.reshape((3, 4))  # Изменение формы
# arr11.resize((2, 6))  # Метод reshape() возвращает ее аргумент с измененной формой, метод resize() изменяет сам массив

# arr12 = np.array([[1, 2], [3, 4]])
# arr13 = np.array([[5, 6], [7, 8]])
# np.vstack((arr12, arr13))  # объединяет массивы по последним осям
# np.hstack((arr12, arr13))  # объединяет массивы по первым осям
# np.column_stack((arr12, arr13))  # array([[1, 2, 5, 6],
#                                          [3, 4, 7, 8]])
# np.row_stack((arr12, arr13))  # array([[1, 2],
#                                        [3, 4],
#                                        [5, 6],
#                                        [7, 8]])

arr14 = np.arange(12)
arr15 = arr14.view()  # создает новый объект массива, являющийся представлением тех же данных
arr15[0: 4] = 2  # данные аrr14 изменятся!!!
arr16 = arr14.copy()  # создаст настоящую копию массива и его данных

arr17 = np.random.sample((2, 3))  # массив со случайными элементами размером 2х3
# np.random.randint(0, 3, (2, 10))  # array([[0, 1, 2, 0, 0, 0, 1, 1, 1, 2],
#                                             [0, 0, 2, 2, 2, 0, 1, 2, 2, 1]])

# np.random.uniform(2, 8, (2, 10))  # array([[3.1517914 ,  3.10313483,  2.84007134,  3.21556436,  4.64531786,
#                                             2.99232714,  7.03064897,  4.38691765,  5.27488548,  2.63472454],
#                                            [6.39470358,  5.63084131,  4.69996748,  7.07260546,  7.44340813,
#                                             4.10722203,  7.52956646,  4.8596943 ,  3.97923973,  5.64505363]])

Z = np.full(10, 2.5)  # Создать вектор размера 10, заполненный числом 2.5


# print(np.logspace(2, 3, 2))  # [ 100. 1000.]
# print(np.random.choice(3, 3, replace=False))  # [1 0 2]  # создает список из 3 элементов в пределах до числа 2
# replace=False значит, что числа не могут повторяться
